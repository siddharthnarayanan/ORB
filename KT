class KinectTracker
{

  PImage display;
   
  KinectTracker()
  {
    // this is an awkard use of a global variable here, but doing it this way for simplicity
    //kinect.startDepth();
    // Make a blank image
    //display = createImage(kinect.width, kinect.height, RGB);
    // Set up the vectors
    for (int i = 0; i < threshold.length; i++) {
      loc[i] = new PVector(0, 0);
      lerpedLoc[i] = new PVector(0, 0);
    }
  }

  void track()
  {
    // get the raw depth as array of integers
    //depth = kinect.getRawDepth();

    // being overly cautious here
    if (depth == null) return;

    float sumX[] = new float[threshold.length];
    float sumY[] = new float[threshold.length];
    float count = 0;
    int lower = 0;
    
    PVector tmp = new PVector(0, 0);

    for (int level = 0; level < threshold.length; level++) {
      valid[level] = 0;
      for (int x = 0; x < kinect.width; x++) {
        for (int y = 0; y < kinect.height; y++) {
          // Mirroring the image
          int offset = kinect.width-x-1 + y*kinect.width;
          // Grabbing the raw depth
          int rawDepth = depth[offset];
  
          // Testing against threshold
          if (level == 0) {
            lower = 0;
          } else {
            lower = threshold[level - 1];
          }
          if (rawDepth >= lower && rawDepth < threshold[level]) {
            sumX[level] += x;
            sumY[level] += y;
            count++;
          }
        }
      }
      // as long as we found something
      if (count != 0) {
        tmp = new PVector(sumX[level]/count, sumY[level]/count);
        if (valid[level] == 1) {
           // we alread had a previously valid marker so we calculate delta
          h_delta[level] = loc[level].x - tmp.x;
        } else {
          // we make initial delta 0 since we just discovered something new
          h_delta[level] = 0;
        }
        loc[level] = tmp;
        valid[level] = 1;
      }
      
      tmp = new PVector(0, 0);
      
      // Interpolating the location, doing it arbitrarily for now
      tmp.x = lerp(lerpedLoc[level].x, loc[level].x, lerp_factor);
      tmp.y = lerp(lerpedLoc[level].y, loc[level].y, lerp_factor);
      
      h_lerped_delta[level] = lerpedLoc[level].x - tmp.x;
      
      lerpedLoc[level].x = tmp.x;
      lerpedLoc[level].y = tmp.y;
      
      // reset count for the next pass
      count = 0;
    } 
  }

  PVector getLerpedPos(int level) {
    if (level >= 0 && level < threshold.length) {
      return lerpedLoc[level];
    } else {
      return new PVector(0, 0);
    }
  }

  PVector getPos(int level) {
    if (level >= 0 && level < threshold.length) {
      return loc[level];
    } else {
      return new PVector(0, 0);
    }
  }

  void display() {
    PImage img = kinect.getDepthImage();

    // being overly cautious here
    if (depth == null || img == null) return;

    // going to rewrite the depth image to show which pixels are in threshold
    display.loadPixels();
    for (int x = 0; x < kinect.width; x++) {
      for (int y = 0; y < kinect.height; y++) {
        // mirroring image
        int offset = kinect.width-x-1 + y*kinect.width;
        // Raw depth
        int rawDepth = depth[offset];
        int pix = x + y*display.width;
        // A red, yellow, green, or blue (depending on level) color instead
        if (rawDepth >= 0 && rawDepth < threshold[0]) {
            display.pixels[pix] = color(150, 50, 50);
        } else if (rawDepth >= threshold[0] && rawDepth < threshold[1]) {
            display.pixels[pix] = color(150, 150, 50);
        } else if (rawDepth >= threshold[1] && rawDepth < threshold[2]) {           
            display.pixels[pix] = color(50, 150, 50);
        } else if (rawDepth >= threshold[2] && rawDepth < threshold[3]) {
            display.pixels[pix] = color(50, 50, 150);
        } else {
            display.pixels[pix] = img.pixels[offset];
        }
      }
    }
    display.updatePixels();

    // draw the image
    image(display, 0, 0);
  }

  int getThreshold(int level) {
    if (level >= 0 && level < threshold.length) {
      return threshold[level];
    } else {
      return 0;
    }
  }

  void setThreshold(int level, int t) {
    if (level >= 0 && level < threshold.length) {
      threshold[level] =  t;
    }
  }
  
  float getHDelta(int level) {
    if (level >= 0 && level < threshold.length) {
      return h_delta[level];
    } else {
      return 0;
    }
  }
  
  float getHLerpedDelta(int level) {
    if (level >= 0 && level < threshold.length) {
      return h_lerped_delta[level] * valid[level];
    } else {
      return 0;
    }
  }
  
  void setLerpFactor(float f) {
    if (f > 0 && f < 1) {
      lerp_factor = f;
    }
  }
  
  int isValid(int level) {
    if (level >= 0 && level < threshold.length) {
      return (valid[level]);
    }
    return 0;
  }
}
